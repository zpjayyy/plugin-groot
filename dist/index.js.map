{"version":3,"sources":["sampleAction.ts","sampleService.ts","sampleProvider.ts","sampleFlowAction.ts","samplePlugin.ts","sampleFlowPlugin.ts","index.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { inject, injectable } from \"inversify\";\nimport {\n    type IAgentRuntime,\n    type Memory,\n    type HandlerCallback,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport {\n    property,\n    globalContainer,\n    BaseInjectableAction,\n    type ActionOptions\n} from \"@elizaos-plugins/plugin-di\";\n\nimport { SampleService } from \"../services/sampleService\";\nimport { SampleProvider } from \"../providers/sampleProvider\";\n\n/**\n * The content class for the action\n */\nexport class CreateResourceContent {\n    @property({\n        description: \"Name of the resource\",\n        schema: z.string(),\n    })\n    name: string;\n\n    @property({\n        description: \"Type of resource (document, image, video)\",\n        schema: z.string(),\n    })\n    type: string;\n\n    @property({\n        description: \"Description of the resource\",\n        schema: z.string(),\n    })\n    description: string;\n\n    @property({\n        description: \"Array of tags to categorize the resource\",\n        schema: z.array(z.string()),\n    })\n    tags: string[];\n}\n\n/**\n * Options for the CreateResource action\n */\nconst options: ActionOptions<CreateResourceContent> = {\n    name: \"CREATE_RESOURCE\",\n    similes: [],\n    description: \"Create a new resource with the specified details\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Create a new resource with the name 'Resource1' and type 'TypeA'\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: `Resource created successfully:\n- Name: Resource1\n- Type: TypeA`,\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Create a new resource with the name 'Resource2' and type 'TypeB'\",\n                },\n            },\n            {\n                user: \"{{agentName}}\",\n                content: {\n                    text: `Resource created successfully:\n- Name: Resource2\n- Type: TypeB`,\n                },\n            },\n        ],\n    ],\n    contentClass: CreateResourceContent,\n};\n\n/**\n * CreateResourceAction\n */\n@injectable()\nexport class CreateResourceAction extends BaseInjectableAction<CreateResourceContent> {\n    constructor(\n        @inject(SampleProvider)\n        private readonly sampleProvider: SampleProvider,\n        @inject(SampleService)\n        private readonly sampleService: SampleService\n    ) {\n        super(options);\n    }\n\n    async validate(\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ): Promise<boolean> {\n        return runtime.getSetting(\"API_KEY\") !== undefined;\n    }\n\n    async execute(\n        content: CreateResourceContent | null,\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        callback?: HandlerCallback\n    ) {\n        if (!content) {\n            const error = \"No content provided for the action.\";\n            elizaLogger.warn(error);\n            await callback?.({ text: error }, []);\n            return;\n        }\n\n        // Call injected provider to do some work\n        try {\n            // Call Service\n            const taskCount = this.sampleService.getGlobalActiveTaskCount();\n            elizaLogger.info(\"Active task count:\", taskCount);\n\n            // Call Provider\n            const result = await this.sampleProvider.get(runtime, message, state);\n            if (!result) {\n                elizaLogger.warn(\"Provider did not return a result.\");\n            } else {\n                elizaLogger.info(\"Privder result:\", result);\n            }\n            // Use result in callback\n        } catch (error) {\n            elizaLogger.error(\"Provider error:\", error);\n        }\n\n        // persist relevant data if needed to memory/knowledge\n        // const memory = {\n        //     type: \"resource\",\n        //     content: resourceDetails.object,\n        //     timestamp: new Date().toISOString()\n        // };\n\n        // await runtime.storeMemory(memory);\n\n        callback?.(\n            {\n                text: `Resource created successfully:\n- Name: ${content.name}\n- Type: ${content.type}\n- Description: ${content.description}\n- Tags: ${content.tags.join(\", \")}\n\nResource has been stored in memory.`,\n            },\n            []\n        );\n    }\n}\n\n// Register the action with the global container\nglobalContainer.bind(CreateResourceAction).toSelf().inRequestScope();\n","import { inject, injectable } from \"inversify\";\nimport {\n    type ServiceType,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    Service,\n    elizaLogger,\n    stringToUuid,\n} from \"@elizaos/core\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\n\nimport { SampleProvider } from \"../providers/sampleProvider\";\n\n// Add SAMPLE to ServiceType enum in types.ts\ndeclare module \"@elizaos/core\" {\n    export enum ServiceType {\n        SAMPLE = \"sample\",\n    }\n}\n\n// The SampleService is a simple service that logs \"Hello world\" every 15 minutes.\n@injectable()\nexport class SampleService extends Service {\n    private runtime: IAgentRuntime | null = null;\n    private intervalId: NodeJS.Timeout | null = null;\n    private readonly DEFAULT_INTERVAL = 15 * 60 * 1000; // 15 minutes in milliseconds\n\n    constructor(\n        @inject(SampleProvider)\n        private readonly sampleProvider: SampleProvider\n    ) {\n        super();\n    }\n\n    static get serviceType(): ServiceType {\n        return \"sample\" as ServiceType.SAMPLE;\n    }\n\n    private static isInitialized = false;\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        // Verify if the service is already initialized\n        if (SampleService.isInitialized) {\n            return;\n        }\n\n        this.runtime = runtime;\n\n        // Start the periodic task\n        this.startPeriodicTask();\n        SampleService.isInitialized = true;\n        elizaLogger.info(\"SampleService initialized and started periodic task\");\n    }\n\n    // Method to get the number of active tasks\n    public getGlobalActiveTaskCount(): number {\n        return SampleService.activeTaskCount;\n    }\n\n    private static activeTaskCount = 0;\n\n    private startPeriodicTask(): void {\n        // Verify if a task is already active\n        if (SampleService.activeTaskCount > 0) {\n            elizaLogger.warn(\n                \"SampleService: Periodic task already running, skipping\"\n            );\n            return;\n        }\n\n        // Clear any existing interval\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n\n        SampleService.activeTaskCount++;\n        elizaLogger.info(\n            `SampleService: Starting periodic task (active tasks: ${SampleService.activeTaskCount})`\n        );\n\n        // Initial call immediately\n        this.fetchSample();\n\n        // Set up periodic calls\n        this.intervalId = setInterval(() => {\n            this.fetchSample();\n        }, this.DEFAULT_INTERVAL);\n    }\n\n    private async fetchSample(): Promise<void> {\n        if (!this.runtime) {\n            elizaLogger.error(\"SampleService: Runtime not initialized\");\n            return;\n        }\n\n        try {\n            // Example of using the sampleProvider\n            // Create dummy memory and state objects for the provider\n            const dummyMemory: Memory = {\n                id: stringToUuid(\"sample-service-trigger\"),\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId,\n                roomId: this.runtime.agentId,\n                content: { text: \"Periodic sample fetch\" },\n                createdAt: Date.now(),\n            };\n\n            const dummyState: State = {\n                userId: this.runtime.agentId,\n                bio: \"\",\n                lore: \"\",\n                messageDirections: \"\",\n                postDirections: \"\",\n                roomId: this.runtime.agentId,\n                actors: \"\",\n                recentMessages: \"\",\n                recentMessagesData: [],\n            };\n            await this.sampleProvider.get(\n                this.runtime,\n                dummyMemory,\n                dummyState\n            );\n\n            // hello world log example\n            elizaLogger.info(\"SampleService: Hello world\");\n\n            elizaLogger.info(\n                \"SampleService: Successfully fetched and processed sample\"\n            );\n        } catch (error) {\n            elizaLogger.error(\"SampleService: Error fetching sample:\", error);\n        }\n    }\n\n    // Method to stop the service\n    stop(): void {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n            SampleService.activeTaskCount--;\n            elizaLogger.info(\n                `SampleService stopped (active tasks: ${SampleService.activeTaskCount})`\n            );\n        }\n        SampleService.isInitialized = false;\n    }\n\n    // Method to manually trigger a sample fetch (for testing)\n    async forceFetch(): Promise<void> {\n        await this.fetchSample();\n    }\n}\n\n// Register the provider with the global container\nglobalContainer.bind(SampleService).toSelf().inSingletonScope();\n\nexport default SampleService;\n","import { inject, injectable } from \"inversify\";\nimport {\n    type Provider,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport { globalContainer, type InjectableProvider } from \"@elizaos-plugins/plugin-di\";\n\n// Dynamic Data Provider\n\nglobalContainer\n    .bind<Record<string, string>>(\"DYNAMIC_DATA\")\n    .toDynamicValue(async () => {\n        return Promise.resolve({ key: \"value\" });\n    });\n\n/**\n * Sample Provider\n */\n@injectable()\nexport class SampleProvider\n    implements InjectableProvider<Record<string, string>>, Provider\n{\n    private _sharedInstance: Record<string, string>;\n\n    constructor(\n        @inject(\"DYNAMIC_DATA\")\n        private readonly dynamicData: Record<string, string>\n    ) {}\n\n    // ---- Implementing the InjectableProvider interface ----\n\n    async getInstance(\n        _runtime: IAgentRuntime\n    ): Promise<Record<string, string>> {\n        if (!this._sharedInstance) {\n            this._sharedInstance = {};\n        }\n        return this._sharedInstance;\n    }\n\n    // ---- Implementing the Provider interface ----\n\n    async get(\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ): Promise<string> {\n        elizaLogger.log(\"Retrieving data in sampleProvider...\");\n        return `Shared instance data: ${JSON.stringify(this._sharedInstance)}\nDynamic data: ${JSON.stringify(this.dynamicData)}\n`;\n    }\n}\n\n// Register the provider with the global container\nglobalContainer.bind(SampleProvider).toSelf().inSingletonScope();\n","import { z } from \"zod\";\nimport { injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, globalContainer, property } from \"@elizaos-plugins/plugin-di\";\nimport { BaseFlowInjectableAction, type ScriptQueryResponse, scripts as defaultFlowScripts } from \"@elizaos-plugins/plugin-flow\";\n\n/**\n * The generated content for the transfer action\n */\nexport class ActionContentDef {\n    @property({\n        description: \"This field should be Cadence or EVM\",\n        examples: [\n            \"If use mentioned Flow native token or smart contract, the field should be Cadence\",\n            \"Otherwise, the field should be EVM\",\n        ],\n        schema: z.string(),\n    })\n    vm: string;\n}\n\n/**\n * The transfer action options\n */\nconst actionOpts: ActionOptions<ActionContentDef> = {\n    name: \"CREATE_RESOURCE_FOR_FLOW\",\n    similes: [],\n    description:\n        \"Create a new resource with the specified details\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Create a new resource on Flow Cadence with the following details\",\n                    action: \"CREATE_RESOURCE_FOR_FLOW\",\n                },\n            },\n        ],\n    ],\n    contentClass: ActionContentDef,\n    suppressInitialMessage: false,\n};\n\n/**\n * Get price action\n *\n * @category Actions\n * @description Get the current price of FLOW token or stFLOW token\n */\n@injectable()\nexport class SampleFlowAction extends BaseFlowInjectableAction<ActionContentDef> {\n    constructor() {\n        super(actionOpts);\n    }\n\n    /**\n     * Validate if the action can be executed\n     */\n    async validate(_runtime: IAgentRuntime, message: Memory, _state?: State): Promise<boolean> {\n        const keywords: string[] = [\"resource\", \"资源\"];\n        // Check if the message contains the keywords\n        return keywords.some((keyword) =>\n            message.content.text.toLowerCase().includes(keyword.toLowerCase()),\n        );\n    }\n\n    /**\n     * Execute the action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: ActionContentDef | null,\n        runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ): Promise<ScriptQueryResponse | null> {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        const resp: ScriptQueryResponse = {\n            ok: false,\n        };\n\n        const agentWalletAddress = runtime.getSetting('FLOW_ADDRESS');\n        let data: string;\n        try {\n            data = await this.walletSerivce.executeScript(\n                defaultFlowScripts.mainGetAccountInfo,\n                (arg, t) => [arg(agentWalletAddress, t.Address)],\n                \"\",\n            );\n        } catch (err) {\n            resp.error = err.message;\n        }\n        if (data) {\n            resp.ok = true;\n            resp.data = JSON.stringify(data);\n        } else {\n            resp.error = resp.error ?? \"Unknown error\";\n        }\n\n        // Check if the response is not ok\n        if (!resp.ok) {\n            elizaLogger.error(\"Error:\", resp.error);\n            callback?.({\n                text: `Unable to load balance of wallet ${agentWalletAddress}`,\n                content: {\n                    error: resp.error ?? \"Unknown error\",\n                },\n                source: \"FlowBlockchain\",\n            });\n        }\n\n        // Some logic to handle creating the resource in the specific VM\n        // This is just a placeholder\n        // ..................\n\n        // Send the response to the Eliza runtime\n        callback?.({\n            text: `Resource created successfully at VM: ${content.vm}`,\n            source: \"FlowBlockchain\",\n        });\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n    }\n}\n\n// Register the transfer action\nglobalContainer.bind(SampleFlowAction).toSelf().inRequestScope();\n","import type { PluginOptions } from '@elizaos-plugins/plugin-di';\nimport { CreateResourceAction } from \"./actions/sampleAction\";\nimport { SampleProvider } from \"./providers/sampleProvider\";\nimport { SampleService } from './services/sampleService';\n\nexport const samplePlugin: PluginOptions = {\n    name: \"sample\",\n    description: \"Enables creation and management of generic resources\",\n    actions: [CreateResourceAction],\n    providers: [SampleProvider],\n    services: [SampleService],\n    evaluators: [],\n    clients: [],\n};\n\nexport default samplePlugin;\n","import type { PluginOptions } from '@elizaos-plugins/plugin-di';\nimport { FlowWalletService } from '@elizaos-plugins/plugin-flow';\n\nimport { CreateResourceAction } from \"./actions/sampleAction\";\nimport { SampleFlowAction } from './actions/sampleFlowAction';\nimport { SampleProvider } from \"./providers/sampleProvider\";\nimport { SampleService } from './services/sampleService';\n\nexport const sampleFlowPlugin: PluginOptions = {\n    name: \"sample\",\n    description: \"Enables creation and management of generic resources\",\n    actions: [CreateResourceAction, SampleFlowAction],\n    providers: [SampleProvider],\n    services: [SampleService, FlowWalletService],\n    evaluators: [],\n    clients: [],\n};\n\nexport default sampleFlowPlugin;\n","export * from \"./actions/sampleAction\";\nexport * from \"./actions/sampleFlowAction\";\nexport * from \"./providers/sampleProvider\";\nexport * from \"./services/sampleService\";\nexport * from \"./samplePlugin\";\nexport * from \"./sampleFlowPlugin\";\n\nimport { samplePlugin } from \"./samplePlugin\";\n\nexport default samplePlugin;\n"],"mappings":"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","names":["z","inject","injectable","elizaLogger","property","globalContainer","BaseInjectableAction","inject","injectable","Service","elizaLogger","stringToUuid","globalContainer","inject","injectable","elizaLogger","globalContainer","globalContainer","bind","toDynamicValue","Promise","resolve","key","SampleProvider","_sharedInstance","constructor","dynamicData","getInstance","_runtime","get","_message","_state","elizaLogger","log","JSON","stringify","toSelf","inSingletonScope","SampleService","Service","runtime","intervalId","DEFAULT_INTERVAL","constructor","sampleProvider","serviceType","isInitialized","initialize","startPeriodicTask","elizaLogger","info","getGlobalActiveTaskCount","activeTaskCount","warn","clearInterval","fetchSample","setInterval","error","dummyMemory","id","stringToUuid","userId","agentId","roomId","content","text","createdAt","Date","now","dummyState","bio","lore","messageDirections","postDirections","actors","recentMessages","recentMessagesData","get","stop","forceFetch","globalContainer","bind","toSelf","inSingletonScope","CreateResourceContent","name","type","description","tags","schema","z","string","array","options","similes","examples","user","content","text","contentClass","CreateResourceAction","BaseInjectableAction","constructor","sampleProvider","sampleService","validate","runtime","_message","_state","getSetting","undefined","execute","message","state","callback","error","elizaLogger","warn","taskCount","getGlobalActiveTaskCount","info","result","get","join","globalContainer","bind","toSelf","inRequestScope","z","injectable","elizaLogger","globalContainer","property","BaseFlowInjectableAction","scripts","defaultFlowScripts","ActionContentDef","vm","description","examples","schema","z","string","actionOpts","name","similes","user","content","text","action","contentClass","suppressInitialMessage","SampleFlowAction","BaseFlowInjectableAction","constructor","validate","_runtime","message","_state","keywords","some","keyword","toLowerCase","includes","execute","runtime","_message","callback","elizaLogger","warn","log","resp","ok","agentWalletAddress","getSetting","data","walletSerivce","executeScript","defaultFlowScripts","mainGetAccountInfo","arg","t","Address","err","error","JSON","stringify","source","globalContainer","bind","toSelf","inRequestScope","samplePlugin","name","description","actions","CreateResourceAction","providers","SampleProvider","services","SampleService","evaluators","clients","FlowWalletService","sampleFlowPlugin","name","description","actions","CreateResourceAction","SampleFlowAction","providers","SampleProvider","services","SampleService","FlowWalletService","evaluators","clients","samplePlugin"]}